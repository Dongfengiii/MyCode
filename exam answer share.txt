

Q1
TFFFTT

Q2.1
5

Q2.2
B
E

Q2.3
CDFJ

Q2.4
True

Q2.5
True

Q3

Q3.1
J->C
I->H


Q3.2
No forward Edge

Q3.3
H->F
B->A
B->A
B->G
E->A
E->I

Q3.4
E

Q3.5
J




Q4

(1) We should run dijkstra algorithm on graph G*.
The vertices set V* of G* is: all new node and u 
The edges set E* of G* is: all edge in e'
Then, we can get a distance array: dist*[] in O(n*^2)

(2) Then, run follows algorithm:

foreach vertex v in V
    foreach vertex v* in V*
        if (v, v*) in e' 
            if dist[v] < dist*[v*] + w(v, v*)
                return False
            end if
        end if
    end for
end for
return true

Above algorithm will fun in O(n n*)

Proof: the shortest distance between u and v, will become: 
dist[v], remain the old path
OR
dist*[v] + w(v, v*), become new path.

This method will run in O(n n*) + O(n*^2)
where n is the number of vertex in old graph, n* is the number of vertex in newly add graph.



Q5

Assume E1 represents the edges of old MST
Assume E2 represents the new edges.
We sort the E1 and E2 in ascending order.

Then, compare each group of (e1, e2) in E1 and E2
if e1>=e2, return false
otherwise, return true

That because if there is an edge e2 in E2 less than e1 in E1, accroding to Kruskal algorithm, e2 must be selected.

The algorithm will run in O(ElogE) because we can just sort the E1 and E2.






Q6

We can just find all the SCC in graph.
(1) If the number of SCC larger than 2, return False
That is because if we only insert 1 edge, the number of SCC will decrease no more than 1.
(2) If the number of SCC equals to 2, assume the 2 SCC named: SCC1 and SCC2
We can pick one of the vertex in SCC1 named v1;
We can pick one of the vertex in SCC2 named v2;
We use DFS to check that whether v1 can connect to v2 or v2 can connect to v1.
If either holds, return True; otherwise, return false

That is because, v1 connect to all the other node of SCC1 , v2 connect to all the other node of SCC2. 
If v1 connect to v2, then we can just add a new edge between v2 to v1, then entire graph will become connected.
If v2 connect to v1, it is similar.

The algorithm will run in O(V + E). Because we should just: 
(1) Calculate SCC spend O(V+E) time
(2) DFS between v1 and v1, spend O(V+E) time.



Q7

We can just use DFS
We create 2 array:
(1) order: represents the pre visit time
(2) low: represents the minimum node index, which can be visited by current node.
Then, we run DFS, and fill order array and low array
When we finish visiting node i, if If low[i] > order[root(i)] holds, then root(i)->i is the such edge.

We just use DFS to traverse the graph, fill array will spend constant time.
So, the algorithm will run in O(V+E)






